ابتدا کوچکترین جد مشترک
$LCA$
 را پیدا می‌کنیم و برای این کار از ریشه شروع میکنیم. اگر از هر دو مقدار a,b بیشتر بود تابع 
$LCA$
  را به صورت بازگشتی بین فرزند چپ 
$root$
   و مقادیر 
   $a$
    و
    $b$
     صدا زده می‌شود در غیر این صورت اگر 
$root$
     از هر دو مقدار کوچکتر بود تابع مورد نظر به صورت بازگشتی بین فرزند راست و اعداد 
   $a$
    و
    $b$
        صدا زده می‌شود و در صورتی که
 $root$      
         بین
    $a$
    و
    $b$
            باشد کوچکترین جد مشترک ما همین است. بدیهی است که این کار از پیچیدگی زمانی 
$O(h)$
             است.
حال تابع 
$max \underline \; element \underline \; in  \underline \; path$
 را تعریف می‌کنیم که یکبار برای 
 $(b, LCA)$
  پیدا شده انجام می‌شود و یکبار برای 
 $(a, LCA)$
   و با استفاده از این تابع ماکزیمم بین یک گره و گرهی از جدش پیدا می‌شود و این دو مقدار را مقایسه کرده و ماکسیمم این دو مقدار پاسخ نهایی ما است که پیاده سازی آن به صورت زیر است:
\begin{flushleft}
$max \underline \; element \underline \; in  \underline \; path(x, node)$\\
    $\qquad maximum = max(value, node.value)$\\
    $\qquad while(node.value ! = x)$\\
           $\qquad \qquad if(node.value > x)$\\
                 $\qquad \qquad \qquad maximum = max(x, node.value)$\\
                 $\qquad \qquad \qquad node = node.left$\\
           $\qquad \qquad else$\\
                 $\qquad \qquad \qquad maximum = max(x, node.value)$\\
                 $\qquad \qquad \qquad node = node.right$\\
    $\qquad return \; max(maximum, x)$\\
 \end{flushleft}
\begin{flushright}
بدیهی است که این تابع برای 
$max \underline \; element \underline \; in  \underline \; path(a, lca)$
 نهایتا از پیچیدگی زمانی
$height(a)  - height(lca)$
و برای 
$max \underline \; element \underline \; in  \underline \; path(b, lca)$
 نهایتا از پیچیدگی زمانی
$height(b)  - height(lca)$
می‌باشد.
 پس  حل این مسئله با پیچیدگی زمانی
$O(h)$
  امکان پذیر است.
  \end{flushright}
